<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MBT Physics Engine - Complete</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Monaco', 'Consolas', monospace;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
            color: #ffffff;
            min-height: 100vh;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2em;
            margin: 0;
            background: linear-gradient(45deg, #00ff88, #0099ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .container {
            display: grid;
            grid-template-columns: 200px 1fr 200px;
            gap: 20px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .sidebar {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .main-area {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
        }

        .canvas-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 15px;
            height: 600px;
        }

        .canvas-panel {
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .canvas-title {
            text-align: center;
            font-size: 0.9em;
            font-weight: bold;
            margin-bottom: 10px;
        }

        canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
            background: #000;
            cursor: crosshair;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tool-section {
            margin-bottom: 20px;
        }

        .tool-section h3 {
            color: #00ff88;
            margin-bottom: 10px;
            font-size: 1em;
        }

        .tool-button {
            width: 100%;
            padding: 10px;
            margin: 5px 0;
            border: none;
            border-radius: 8px;
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.3) 0%, rgba(0, 153, 255, 0.3) 100%);
            color: white;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.8em;
        }

        .tool-button:hover {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.5) 0%, rgba(0, 153, 255, 0.5) 100%);
            transform: translateY(-2px);
        }

        .tool-button.active {
            background: linear-gradient(135deg, #00ff88 0%, #0099ff 100%);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9em;
            color: #00ff88;
        }

        input[type="range"] {
            width: 100%;
            margin: 5px 0;
            -webkit-appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: linear-gradient(45deg, #00ff88, #0099ff);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 255, 136, 0.3);
        }

        .value-display {
            text-align: center;
            font-size: 0.8em;
            color: #0099ff;
            margin-top: 5px;
        }

        .main-button {
            width: 100%;
            padding: 12px;
            margin: 5px 0;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #00ff88 0%, #0099ff 100%);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1em;
        }

        .main-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 255, 136, 0.4);
        }

        .main-button.active {
            background: linear-gradient(135deg, #ff0099 0%, #ff6b35 100%);
        }

        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 20px;
        }

        .metric {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.2em;
            font-weight: bold;
            color: #00ff88;
        }

        .metric-label {
            font-size: 0.7em;
            opacity: 0.8;
            margin-top: 5px;
        }

        .quantum { color: #00ff88; }
        .atomic { color: #ff6b35; }
        .molecular { color: #4ecdc4; }
        .orbital { color: #ffe66d; }
        .cosmic { color: #c7ceea; }
        .energy { color: #ff69b4; }

        .status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.8em;
        }

        .fps { color: #00ff88; }
        .running { color: #0099ff; }

        .instructions {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 0.8em;
            border: 1px solid rgba(0, 255, 136, 0.3);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üåå MBT Physics Engine</h1>
        <p>Interactive Unified Field Theory: Motion = Being</p>
    </div>

    <div class="instructions">
        <strong>How to use:</strong><br>
        1. Click START to begin simulation<br>
        2. Select a tool (Quantum, Atom, etc.)<br>
        3. Click on any canvas to add particles/objects<br>
        4. Adjust physics parameters with sliders<br>
        5. Try the preset scenarios!
    </div>

    <div class="container">
        <div class="sidebar">
            <div class="tool-section">
                <h3>üéÆ Tools</h3>
                <button class="tool-button active" data-tool="quantum">‚öõÔ∏è Quantum Particle</button>
                <button class="tool-button" data-tool="atom">üî¥ Atom</button>
                <button class="tool-button" data-tool="molecule">üß¨ Molecule</button>
                <button class="tool-button" data-tool="planet">ü™ê Planet</button>
                <button class="tool-button" data-tool="energy">‚ö° Energy</button>
            </div>

            <div class="tool-section">
                <h3>üíæ Presets</h3>
                <button class="tool-button" onclick="loadPreset('hydrogen')">H Hydrogen</button>
                <button class="tool-button" onclick="loadPreset('water')">üíß Water</button>
                <button class="tool-button" onclick="loadPreset('solar')">‚òÄÔ∏è Solar System</button>
                <button class="tool-button" onclick="loadPreset('galaxy')">üåå Galaxy</button>
            </div>

            <button class="main-button" id="startBtn" onclick="toggleSimulation()">‚ñ∂Ô∏è START</button>
            <button class="main-button" onclick="resetSimulation()">üîÑ RESET</button>
        </div>

        <div class="main-area">
            <div class="canvas-grid">
                <div class="canvas-panel">
                    <div class="canvas-title quantum">üî¨ QUANTUM FIELD</div>
                    <canvas id="quantumCanvas" width="250" height="180"></canvas>
                </div>

                <div class="canvas-panel">
                    <div class="canvas-title atomic">‚öõÔ∏è ATOMIC STRUCTURE</div>
                    <canvas id="atomicCanvas" width="250" height="180"></canvas>
                </div>

                <div class="canvas-panel">
                    <div class="canvas-title molecular">üß¨ MOLECULAR BONDS</div>
                    <canvas id="molecularCanvas" width="250" height="180"></canvas>
                </div>

                <div class="canvas-panel">
                    <div class="canvas-title orbital">ü™ê ORBITAL MECHANICS</div>
                    <canvas id="orbitalCanvas" width="250" height="180"></canvas>
                </div>

                <div class="canvas-panel">
                    <div class="canvas-title cosmic">üåå COSMIC STRUCTURE</div>
                    <canvas id="cosmicCanvas" width="250" height="180"></canvas>
                </div>

                <div class="canvas-panel">
                    <div class="canvas-title energy">‚ö° ENERGY FIELDS</div>
                    <canvas id="energyCanvas" width="250" height="180"></canvas>
                </div>
            </div>
        </div>

        <div class="sidebar">
            <div class="tool-section">
                <h3>üéõÔ∏è Physics Parameters</h3>
                
                <div class="control-group">
                    <label>Œ± - Resistance Coupling</label>
                    <input type="range" id="alpha" min="0.1" max="3.0" step="0.1" value="1.0" oninput="updateParam('alpha', this.value)">
                    <div class="value-display" id="alpha-display">1.0</div>
                </div>

                <div class="control-group">
                    <label>Œ≤ - Curvature Decay</label>
                    <input type="range" id="beta" min="0.1" max="2.0" step="0.1" value="0.5" oninput="updateParam('beta', this.value)">
                    <div class="value-display" id="beta-display">0.5</div>
                </div>

                <div class="control-group">
                    <label>Œ≥ - Frequency Width</label>
                    <input type="range" id="gamma" min="0.5" max="5.0" step="0.1" value="2.0" oninput="updateParam('gamma', this.value)">
                    <div class="value-display" id="gamma-display">2.0</div>
                </div>

                <div class="control-group">
                    <label>Œ¥ - Memory Decay</label>
                    <input type="range" id="delta" min="0.01" max="1.0" step="0.01" value="0.1" oninput="updateParam('delta', this.value)">
                    <div class="value-display" id="delta-display">0.1</div>
                </div>

                <div class="control-group">
                    <label>üéÆ Speed</label>
                    <input type="range" id="speed" min="10" max="200" step="10" value="50" oninput="updateSpeed(this.value)">
                    <div class="value-display" id="speed-display">50 ms</div>
                </div>
            </div>

            <div class="metrics">
                <div class="metric quantum">
                    <div class="metric-value" id="quantumMetric">0.00</div>
                    <div class="metric-label">Quantum Energy</div>
                </div>
                <div class="metric atomic">
                    <div class="metric-value" id="atomicMetric">0</div>
                    <div class="metric-label">Atoms</div>
                </div>
                <div class="metric molecular">
                    <div class="metric-value" id="molecularMetric">0.00</div>
                    <div class="metric-label">Bonds</div>
                </div>
                <div class="metric orbital">
                    <div class="metric-value" id="orbitalMetric">0.00</div>
                    <div class="metric-label">Mass</div>
                </div>
                <div class="metric cosmic">
                    <div class="metric-value" id="cosmicMetric">0.000</div>
                    <div class="metric-label">Structure</div>
                </div>
                <div class="metric energy">
                    <div class="metric-value" id="energyMetric">0.0</div>
                    <div class="metric-label">Energy Flow</div>
                </div>
            </div>
        </div>
    </div>

    <div class="status">
        <div class="fps">FPS: <span id="fpsCounter">0</span></div>
        <div class="running">Status: <span id="statusText">Stopped</span></div>
        <div>Tool: <span id="currentTool">Quantum</span></div>
    </div>

    <script>
        // GLOBAL VARIABLES
        let engine = null;
        let isRunning = false;
        let animationId = null;
        let currentTool = 'quantum';
        let frameCount = 0;
        let lastFpsTime = performance.now();

        // COMPLETE MBT PHYSICS ENGINE CLASS
        class MBTEngine {
            constructor() {
                console.log('üåå Initializing MBT Engine...');
                
                this.gridSize = 32;
                this.timeStep = 0;
                this.maxParticles = 100;
                
                // MBT Parameters
                this.alpha = 1.0;
                this.beta = 0.5;
                this.gamma = 2.0;
                this.delta = 0.1;
                
                // Get canvases and contexts
                this.canvases = {};
                this.contexts = {};
                
                const canvasIds = ['quantum', 'atomic', 'molecular', 'orbital', 'cosmic', 'energy'];
                canvasIds.forEach(id => {
                    this.canvases[id] = document.getElementById(id + 'Canvas');
                    this.contexts[id] = this.canvases[id].getContext('2d');
                    
                    // Add click handlers
                    this.canvases[id].addEventListener('click', (e) => this.handleCanvasClick(id, e));
                    this.canvases[id].addEventListener('contextmenu', (e) => e.preventDefault());
                });
                
                this.initializeFields();
                this.setupControls();
                this.startPerformanceMonitoring();
                
                console.log('‚úÖ MBT Engine ready!');
            }
            
            initializeFields() {
                const size = this.gridSize;
                
                // Initialize all physics fields with proper structure
                this.quantum = {
                    psi: Array(size).fill().map(() => Array(size).fill().map(() => ({
                        real: (Math.random() - 0.5) * 0.1,
                        imag: (Math.random() - 0.5) * 0.1
                    }))),
                    potential: Array(size).fill().map(() => Array(size).fill(0))
                };
                
                this.atomic = {
                    density: Array(size).fill().map(() => Array(size).fill(0))
                };
                
                this.molecular = {
                    bonds: Array(size).fill().map(() => Array(size).fill(0))
                };
                
                this.orbital = {
                    mass: Array(size).fill().map(() => Array(size).fill(0)),
                    velocity: Array(size).fill().map(() => Array(size).fill().map(() => ({x: 0, y: 0})))
                };
                
                this.cosmic = {
                    density: Array(size).fill().map(() => Array(size).fill(1 + Math.random() * 0.1))
                };
                
                this.energy = {
                    plasma: Array(size).fill().map(() => Array(size).fill(0)),
                    magnetic: Array(size).fill().map(() => Array(size).fill().map(() => ({x: 0, y: 0, z: 0})))
                };
                
                this.particles = [];
                this.isRunning = false;
                this.lastFrameTime = performance.now();
                this.fps = 0;
                
                this.seedInitialConditions();
            }
            
            seedInitialConditions() {
                const center = this.gridSize / 2;
                
                // Create quantum wave packet
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const r2 = (i - center) ** 2 + (j - center) ** 2;
                        const amplitude = Math.exp(-r2 / 32);
                        this.quantum.psi[i][j].real = amplitude * Math.cos(0.3 * i);
                        this.quantum.psi[i][j].imag = amplitude * Math.sin(0.3 * i);
                    }
                }
                
                // Add some atoms
                for (let k = 0; k < 4; k++) {
                    const x = 6 + k * 5;
                    const y = Math.floor(center);
                    if (x < this.gridSize && y < this.gridSize) {
                        this.atomic.density[x][y] = 1.0;
                        this.quantum.potential[x][y] = -5.0;
                    }
                }
                
                // Central mass
                this.orbital.mass[Math.floor(center)][Math.floor(center)] = 10.0;
                
                console.log('üå± Initial conditions set');
            }
            
            masterMBTFunction(r, v, omega, t) {
                const scale = 1e-10;
                const C_r = 1.0 / (1 + (r / scale) ** this.beta);
                const v_mag = Math.abs(v);
                const R_v = this.alpha * v_mag * v_mag / (1 + v_mag);
                const Omega_freq = Math.exp(-(omega * omega) / (2 * this.gamma * this.gamma));
                const T_t = t > 0 ? Math.exp(-t / this.delta) : 1.0;
                
                return C_r * R_v * Omega_freq * T_t;
            }
            
            step() {
                const dt = 1e-15;
                
                // Evolve all scales
                this.evolveQuantum(dt);
                this.evolveAtomic(dt);
                this.evolveMolecular(dt);
                this.evolveOrbital(dt);
                this.evolveCosmic(dt);
                this.evolveEnergy(dt);
                
                // Cross-scale coupling
                this.crossScaleCoupling();
                
                // Update particles
                this.updateParticles(dt);
                
                this.timeStep++;
                this.updateMetrics();
                this.render();
            }
            
            evolveQuantum(dt) {
                const newPsi = this.quantum.psi.map(row => row.map(cell => ({...cell})));
                
                for (let i = 1; i < this.gridSize - 1; i++) {
                    for (let j = 1; j < this.gridSize - 1; j++) {
                        const lapR = this.quantum.psi[i-1][j].real + this.quantum.psi[i+1][j].real +
                                    this.quantum.psi[i][j-1].real + this.quantum.psi[i][j+1].real - 
                                    4 * this.quantum.psi[i][j].real;
                        
                        const lapI = this.quantum.psi[i-1][j].imag + this.quantum.psi[i+1][j].imag +
                                    this.quantum.psi[i][j-1].imag + this.quantum.psi[i][j+1].imag - 
                                    4 * this.quantum.psi[i][j].imag;
                        
                        const V = this.quantum.potential[i][j];
                        const coeff = -0.001 * dt;
                        
                        newPsi[i][j].real += coeff * lapI - V * dt * this.quantum.psi[i][j].imag;
                        newPsi[i][j].imag -= coeff * lapR + V * dt * this.quantum.psi[i][j].real;
                    }
                }
                
                this.quantum.psi = newPsi;
                this.normalizeQuantumState();
            }
            
            normalizeQuantumState() {
                let norm = 0;
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        norm += this.quantum.psi[i][j].real ** 2 + this.quantum.psi[i][j].imag ** 2;
                    }
                }
                norm = Math.sqrt(norm);
                
                if (norm > 1e-10) {
                    for (let i = 0; i < this.gridSize; i++) {
                        for (let j = 0; j < this.gridSize; j++) {
                            this.quantum.psi[i][j].real /= norm;
                            this.quantum.psi[i][j].imag /= norm;
                        }
                    }
                }
            }
            
            evolveAtomic(dt) {
                for (let i = 1; i < this.gridSize - 1; i++) {
                    for (let j = 1; j < this.gridSize - 1; j++) {
                        const laplacian = this.atomic.density[i-1][j] + this.atomic.density[i+1][j] +
                                         this.atomic.density[i][j-1] + this.atomic.density[i][j+1] - 
                                         4 * this.atomic.density[i][j];
                        
                        this.atomic.density[i][j] += 0.01 * dt * laplacian;
                        this.atomic.density[i][j] *= 0.999;
                        this.atomic.density[i][j] = Math.max(0, this.atomic.density[i][j]);
                    }
                }
            }
            
            evolveMolecular(dt) {
                for (let i = 1; i < this.gridSize - 1; i++) {
                    for (let j = 1; j < this.gridSize - 1; j++) {
                        const laplacian = this.molecular.bonds[i-1][j] + this.molecular.bonds[i+1][j] +
                                         this.molecular.bonds[i][j-1] + this.molecular.bonds[i][j+1] - 
                                         4 * this.molecular.bonds[i][j];
                        
                        this.molecular.bonds[i][j] += 0.005 * dt * laplacian;
                        this.molecular.bonds[i][j] *= 0.9995;
                        this.molecular.bonds[i][j] = Math.max(0, Math.min(1, this.molecular.bonds[i][j]));
                    }
                }
            }
            
            evolveOrbital(dt) {
                const center = this.gridSize / 2;
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        if (this.orbital.mass[i][j] > 0.1) {
                            const r_x = i - center;
                            const r_y = j - center;
                            const r_mag = Math.sqrt(r_x ** 2 + r_y ** 2) + 1e-12;
                            
                            const v = this.orbital.velocity[i][j];
                            const v_mag = Math.sqrt(v.x ** 2 + v.y ** 2);
                            
                            const mbt_factor = this.masterMBTFunction(r_mag, v_mag, v_mag/r_mag, this.timeStep * dt);
                            const a_magnitude = this.alpha * v_mag ** 2 / r_mag * mbt_factor * 0.001;
                            
                            if (r_mag > 1) {
                                this.orbital.velocity[i][j].x += -a_magnitude * r_x / r_mag * dt;
                                this.orbital.velocity[i][j].y += -a_magnitude * r_y / r_mag * dt;
                            }
                        }
                    }
                }
            }
            
            evolveCosmic(dt) {
                for (let i = 1; i < this.gridSize - 1; i += 2) {
                    for (let j = 1; j < this.gridSize - 1; j += 2) {
                        const laplacian = this.cosmic.density[i-1][j] + this.cosmic.density[i+1][j] +
                                         this.cosmic.density[i][j-1] + this.cosmic.density[i][j+1] - 
                                         4 * this.cosmic.density[i][j];
                        
                        this.cosmic.density[i][j] += 0.0001 * dt * laplacian;
                    }
                }
            }
            
            evolveEnergy(dt) {
                // Energy from other scales
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const quantumE = this.quantum.psi[i][j].real ** 2 + this.quantum.psi[i][j].imag ** 2;
                        const atomicE = this.atomic.density[i][j];
                        const molecularE = this.molecular.bonds[i][j];
                        const orbitalE = this.orbital.mass[i][j];
                        
                        const totalEnergy = quantumE * 0.1 + atomicE * 0.01 + molecularE * 0.05 + orbitalE * 0.001;
                        this.energy.plasma[i][j] += totalEnergy * dt;
                    }
                }
                
                // Simple plasma evolution
                for (let i = 1; i < this.gridSize - 1; i++) {
                    for (let j = 1; j < this.gridSize - 1; j++) {
                        const laplacian = this.energy.plasma[i-1][j] + this.energy.plasma[i+1][j] +
                                         this.energy.plasma[i][j-1] + this.energy.plasma[i][j+1] - 
                                         4 * this.energy.plasma[i][j];
                        
                        this.energy.plasma[i][j] += dt * laplacian * 0.1;
                        this.energy.plasma[i][j] *= 0.99;
                        
                        const current = this.energy.plasma[i][j];
                        this.energy.magnetic[i][j].z += current * dt * 0.01;
                        this.energy.magnetic[i][j].z *= 0.995;
                    }
                }
                
                // Periodic energy bursts
                if (this.timeStep % 100 === 0) {
                    const x = Math.floor(Math.random() * this.gridSize);
                    const y = Math.floor(Math.random() * this.gridSize);
                    this.energy.plasma[x][y] += Math.random() * 2;
                    this.createParticle(x, y, 'energy', 2);
                }
            }
            
            crossScaleCoupling() {
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const psiDensity = this.quantum.psi[i][j].real ** 2 + this.quantum.psi[i][j].imag ** 2;
                        this.atomic.density[i][j] += psiDensity * 0.01;
                        this.molecular.bonds[i][j] += this.atomic.density[i][j] * 0.001;
                        this.orbital.mass[i][j] += this.molecular.bonds[i][j] * 1e-6;
                        this.cosmic.density[i][j] += this.orbital.mass[i][j] * 1e-8;
                    }
                }
            }
            
            createParticle(x, y, type, energy = 1.0) {
                if (this.particles.length >= this.maxParticles) {
                    this.particles.shift();
                }
                
                this.particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    type: type,
                    energy: energy,
                    age: 0,
                    maxAge: 50 + Math.random() * 100,
                    color: this.getParticleColor(type, energy)
                });
            }
            
            getParticleColor(type, energy) {
                const intensity = Math.min(255, energy * 128);
                switch (type) {
                    case 'quantum': return `rgb(0, ${intensity}, 255)`;
                    case 'atomic': return `rgb(${intensity}, 100, 35)`;
                    case 'molecular': return `rgb(76, ${intensity}, 196)`;
                    case 'orbital': return `rgb(${intensity}, ${intensity}, 109)`;
                    case 'energy': return `rgb(${intensity}, 105, 180)`;
                    default: return `rgb(${intensity}, ${intensity}, ${intensity})`;
                }
            }
            
            updateParticles(dt) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.x += p.vx * dt * 5;
                    p.y += p.vy * dt * 5;
                    p.age += dt * 30;
                    p.energy *= 0.998;
                    
                    // Apply simple field forces
                    const gridX = Math.floor(p.x) % this.gridSize;
                    const gridY = Math.floor(p.y) % this.gridSize;
                    if (gridX >= 0 && gridX < this.gridSize && gridY >= 0 && gridY < this.gridSize) {
                        const force = this.energy.plasma[gridX][gridY] * 0.01;
                        p.vx += force * (Math.random() - 0.5) * dt;
                        p.vy += force * (Math.random() - 0.5) * dt;
                    }
                    
                    // Remove old/dead particles
                    if (p.age > p.maxAge || p.energy < 0.01) {
                        this.particles.splice(i, 1);
                    }
                }
            }
            
            updateMetrics() {
                if (this.timeStep % 10 !== 0) return;
                
                let quantumEnergy = 0;
                let atomicPop = 0;
                let molecularBonds = 0;
                let orbitalMass = 0;
                let cosmicStruct = 0;
                let energyFlow = 0;
                
                // Sample subset for performance
                for (let i = 0; i < this.gridSize; i += 2) {
                    for (let j = 0; j < this.gridSize; j += 2) {
                        quantumEnergy += this.quantum.psi[i][j].real ** 2 + this.quantum.psi[i][j].imag ** 2;
                        atomicPop += this.atomic.density[i][j];
                        molecularBonds += this.molecular.bonds[i][j];
                        orbitalMass += this.orbital.mass[i][j];
                        cosmicStruct += (this.cosmic.density[i][j] - 1) ** 2;
                        energyFlow += Math.abs(this.energy.plasma[i][j]);
                    }
                }
                
                document.getElementById('quantumMetric').textContent = quantumEnergy.toFixed(2);
                document.getElementById('atomicMetric').textContent = Math.floor(atomicPop * 4);
                document.getElementById('molecularMetric').textContent = (molecularBonds * 4).toFixed(2);
                document.getElementById('orbitalMetric').textContent = (orbitalMass * 4).toFixed(2);
                document.getElementById('cosmicMetric').textContent = (cosmicStruct * 4).toFixed(3);
                document.getElementById('energyMetric').textContent = (energyFlow * 4).toFixed(1);
            }
            
            render() {
                this.renderQuantum();
                this.renderAtomic();
                this.renderMolecular();
                this.renderOrbital();
                this.renderCosmic();
                this.renderEnergy();
                this.renderParticles();
            }
            
            renderQuantum() {
                const ctx = this.contexts.quantum;
                const canvas = this.canvases.quantum;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const x = Math.floor((i / this.gridSize) * canvas.width);
                        const y = Math.floor((j / this.gridSize) * canvas.height);
                        
                        if (x < canvas.width && y < canvas.height) {
                            const intensity = Math.sqrt(
                                this.quantum.psi[i][j].real ** 2 + this.quantum.psi[i][j].imag ** 2
                            );
                            const phase = Math.atan2(this.quantum.psi[i][j].imag, this.quantum.psi[i][j].real);
                            
                            const pixelIndex = (y * canvas.width + x) * 4;
                            const colorIntensity = Math.min(255, intensity * 1000);
                            
                            const hue = (phase + Math.PI) / (2 * Math.PI);
                            if (hue < 0.33) {
                                imageData.data[pixelIndex] = colorIntensity;
                                imageData.data[pixelIndex + 1] = 0;
                                imageData.data[pixelIndex + 2] = 0;
                            } else if (hue < 0.67) {
                                imageData.data[pixelIndex] = 0;
                                imageData.data[pixelIndex + 1] = colorIntensity;
                                imageData.data[pixelIndex + 2] = 0;
                            } else {
                                imageData.data[pixelIndex] = 0;
                                imageData.data[pixelIndex + 1] = 0;
                                imageData.data[pixelIndex + 2] = colorIntensity;
                            }
                            imageData.data[pixelIndex + 3] = 255;
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
            renderAtomic() {
                const ctx = this.contexts.atomic;
                const canvas = this.canvases.atomic;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const x = Math.floor((i / this.gridSize) * canvas.width);
                        const y = Math.floor((j / this.gridSize) * canvas.height);
                        
                        if (x < canvas.width && y < canvas.height) {
                            const density = this.atomic.density[i][j];
                            const pixelIndex = (y * canvas.width + x) * 4;
                            const intensity = Math.min(255, density * 200);
                            
                            imageData.data[pixelIndex] = intensity;
                            imageData.data[pixelIndex + 1] = intensity * 0.5;
                            imageData.data[pixelIndex + 2] = 35;
                            imageData.data[pixelIndex + 3] = 255;
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
            renderMolecular() {
                const ctx = this.contexts.molecular;
                const canvas = this.canvases.molecular;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const x = Math.floor((i / this.gridSize) * canvas.width);
                        const y = Math.floor((j / this.gridSize) * canvas.height);
                        
                        if (x < canvas.width && y < canvas.height) {
                            const bonds = this.molecular.bonds[i][j];
                            const pixelIndex = (y * canvas.width + x) * 4;
                            const intensity = Math.min(255, bonds * 255);
                            
                            imageData.data[pixelIndex] = 76;
                            imageData.data[pixelIndex + 1] = intensity;
                            imageData.data[pixelIndex + 2] = 196;
                            imageData.data[pixelIndex + 3] = 255;
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
            renderOrbital() {
                const ctx = this.contexts.orbital;
                const canvas = this.canvases.orbital;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const x = Math.floor((i / this.gridSize) * canvas.width);
                        const y = Math.floor((j / this.gridSize) * canvas.height);
                        
                        if (x < canvas.width && y < canvas.height) {
                            const mass = this.orbital.mass[i][j];
                            const velocity = Math.sqrt(
                                this.orbital.velocity[i][j].x ** 2 + this.orbital.velocity[i][j].y ** 2
                            );
                            
                            const pixelIndex = (y * canvas.width + x) * 4;
                            const massIntensity = Math.min(255, Math.log10(mass + 1) * 100);
                            const velIntensity = Math.min(255, velocity * 500);
                            
                            imageData.data[pixelIndex] = massIntensity;
                            imageData.data[pixelIndex + 1] = massIntensity;
                            imageData.data[pixelIndex + 2] = velIntensity;
                            imageData.data[pixelIndex + 3] = 255;
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
            renderCosmic() {
                const ctx = this.contexts.cosmic;
                const canvas = this.canvases.cosmic;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const x = Math.floor((i / this.gridSize) * canvas.width);
                        const y = Math.floor((j / this.gridSize) * canvas.height);
                        
                        if (x < canvas.width && y < canvas.height) {
                            const density = this.cosmic.density[i][j];
                            const pixelIndex = (y * canvas.width + x) * 4;
                            const intensity = Math.max(0, Math.min(255, (density - 0.9) * 1000));
                            
                            imageData.data[pixelIndex] = intensity * 0.5;
                            imageData.data[pixelIndex + 1] = intensity * 0.5;
                            imageData.data[pixelIndex + 2] = intensity;
                            imageData.data[pixelIndex + 3] = 255;
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
            renderEnergy() {
                const ctx = this.contexts.energy;
                const canvas = this.canvases.energy;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                const imageData = ctx.createImageData(canvas.width, canvas.height);
                
                // Find max for scaling
                let maxPlasma = 0.01;
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        maxPlasma = Math.max(maxPlasma, Math.abs(this.energy.plasma[i][j]));
                    }
                }
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const x = Math.floor((i / this.gridSize) * canvas.width);
                        const y = Math.floor((j / this.gridSize) * canvas.height);
                        
                        if (x < canvas.width && y < canvas.height) {
                            const plasma = Math.abs(this.energy.plasma[i][j]);
                            const magnetic = Math.abs(this.energy.magnetic[i][j].z);
                            
                            const plasmaIntensity = (plasma / maxPlasma) * 255;
                            const magneticIntensity = magnetic * 200;
                            
                            const pixelIndex = (y * canvas.width + x) * 4;
                            imageData.data[pixelIndex] = Math.min(255, plasmaIntensity);
                            imageData.data[pixelIndex + 1] = Math.min(255, plasmaIntensity * 0.4);
                            imageData.data[pixelIndex + 2] = Math.min(255, magneticIntensity);
                            imageData.data[pixelIndex + 3] = 255;
                        }
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
            
            renderParticles() {
                Object.keys(this.contexts).forEach(scaleKey => {
                    const ctx = this.contexts[scaleKey];
                    const canvas = this.canvases[scaleKey];
                    
                    this.particles.forEach(particle => {
                        if (particle.energy > 0.01) {
                            const x = (particle.x / this.gridSize) * canvas.width;
                            const y = (particle.y / this.gridSize) * canvas.height;
                            
                            if (x >= 0 && x < canvas.width && y >= 0 && y < canvas.height) {
                                ctx.fillStyle = particle.color;
                                ctx.globalAlpha = Math.min(1, particle.energy);
                                ctx.beginPath();
                                ctx.arc(x, y, Math.max(1, particle.energy * 2), 0, 2 * Math.PI);
                                ctx.fill();
                                ctx.globalAlpha = 1;
                            }
                        }
                    });
                });
            }
            
            handleCanvasClick(canvasId, event) {
                const rect = event.target.getBoundingClientRect();
                const x = Math.floor((event.clientX - rect.left) / rect.width * this.gridSize);
                const y = Math.floor((event.clientY - rect.top) / rect.height * this.gridSize);
                
                if (x < 0 || x >= this.gridSize || y < 0 || y >= this.gridSize) return;
                
                const intensity = event.shiftKey ? 2.0 : 1.0;
                const isRightClick = event.button === 2;
                
                switch (currentTool) {
                    case 'quantum':
                        if (canvasId === 'quantum') {
                            if (isRightClick) {
                                this.quantum.psi[x][y].real *= 0.5;
                                this.quantum.psi[x][y].imag *= 0.5;
                            } else {
                                this.quantum.psi[x][y].real += intensity * 0.3;
                                this.quantum.psi[x][y].imag += intensity * 0.2;
                                this.createParticle(x, y, 'quantum', intensity);
                            }
                        }
                        break;
                        
                    case 'atom':
                        if (canvasId === 'atomic') {
                            if (isRightClick) {
                                this.atomic.density[x][y] *= 0.7;
                            } else {
                                this.atomic.density[x][y] += intensity;
                                this.quantum.potential[x][y] = -5.0;
                                this.createParticle(x, y, 'atomic', intensity);
                            }
                        }
                        break;
                        
                    case 'molecule':
                        if (canvasId === 'molecular') {
                            if (isRightClick) {
                                this.molecular.bonds[x][y] *= 0.3;
                            } else {
                                this.molecular.bonds[x][y] += intensity * 0.5;
                                this.createParticle(x, y, 'molecular', intensity);
                            }
                        }
                        break;
                        
                    case 'planet':
                        if (canvasId === 'orbital') {
                            if (isRightClick) {
                                this.orbital.mass[x][y] *= 0.5;
                            } else {
                                this.orbital.mass[x][y] += intensity * 2;
                                
                                const center = this.gridSize / 2;
                                const r = Math.sqrt((x - center) ** 2 + (y - center) ** 2);
                                if (r > 2) {
                                    const angle = Math.atan2(y - center, x - center);
                                    const v = Math.sqrt(10 / r) * 0.2;
                                    this.orbital.velocity[x][y].x = -v * Math.sin(angle);
                                    this.orbital.velocity[x][y].y = v * Math.cos(angle);
                                }
                                this.createParticle(x, y, 'orbital', intensity);
                            }
                        }
                        break;
                        
                    case 'energy':
                        if (isRightClick) {
                            this.energy.plasma[x][y] *= 0.3;
                        } else {
                            this.energy.plasma[x][y] += intensity;
                            this.createParticle(x, y, 'energy', intensity);
                        }
                        break;
                }
            }
            
            setupControls() {
                // Tool selection
                document.querySelectorAll('[data-tool]').forEach(button => {
                    button.addEventListener('click', (e) => {
                        currentTool = e.target.dataset.tool;
                        document.querySelectorAll('[data-tool]').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        document.getElementById('currentTool').textContent = currentTool.charAt(0).toUpperCase() + currentTool.slice(1);
                    });
                });
            }
            
            loadPreset(presetName) {
                this.reset();
                setTimeout(() => {
                    switch (presetName) {
                        case 'hydrogen':
                            this.createHydrogen();
                            break;
                        case 'water':
                            this.createWater();
                            break;
                        case 'solar':
                            this.createSolarSystem();
                            break;
                        case 'galaxy':
                            this.createGalaxy();
                            break;
                    }
                }, 100);
            }
            
            createHydrogen() {
                const center = this.gridSize / 2;
                this.quantum.potential[center][center] = -20;
                
                for (let i = 0; i < this.gridSize; i++) {
                    for (let j = 0; j < this.gridSize; j++) {
                        const r = Math.sqrt((i - center) ** 2 + (j - center) ** 2);
                        const psi = Math.exp(-r / 3);
                        this.quantum.psi[i][j].real = psi;
                        this.quantum.psi[i][j].imag = 0;
                        this.atomic.density[i][j] = psi * psi;
                    }
                }
                this.normalizeQuantumState();
            }
            
            createWater() {
                const center = this.gridSize / 2;
                
                // Oxygen
                this.atomic.density[center][center] = 8;
                
                // Hydrogens
                this.atomic.density[center - 4][center + 2] = 1;
                this.atomic.density[center + 4][center + 2] = 1;
                
                // Bonds
                for (let t = 0; t <= 1; t += 0.2) {
                    const x1 = Math.floor(center + t * -4);
                    const y1 = Math.floor(center + t * 2);
                    const x2 = Math.floor(center + t * 4);
                    const y2 = Math.floor(center + t * 2);
                    
                    if (x1 >= 0 && x1 < this.gridSize && y1 >= 0 && y1 < this.gridSize) {
                        this.molecular.bonds[x1][y1] = 0.8;
                    }
                    if (x2 >= 0 && x2 < this.gridSize && y2 >= 0 && y2 < this.gridSize) {
                        this.molecular.bonds[x2][y2] = 0.8;
                    }
                }
            }
            
            createSolarSystem() {
                const center = this.gridSize / 2;
                
                // Sun
                this.orbital.mass[center][center] = 50;
                
                // Planets
                const planets = [
                    { r: 6, m: 0.5 },
                    { r: 10, m: 0.8 },
                    { r: 14, m: 1.0 },
                    { r: 18, m: 0.3 }
                ];
                
                planets.forEach((planet, i) => {
                    const angle = (i * 2 * Math.PI) / planets.length;
                    const x = Math.floor(center + planet.r * Math.cos(angle));
                    const y = Math.floor(center + planet.r * Math.sin(angle));
                    
                    if (x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize) {
                        this.orbital.mass[x][y] = planet.m;
                        const v = Math.sqrt(50 / planet.r) * 0.1;
                        this.orbital.velocity[x][y].x = -v * Math.sin(angle);
                        this.orbital.velocity[x][y].y = v * Math.cos(angle);
                    }
                });
            }
            
            createGalaxy() {
                const center = this.gridSize / 2;
                
                // Central black hole
                this.orbital.mass[center][center] = 100;
                
                // Spiral arms
                for (let r = 3; r < this.gridSize / 2; r += 2) {
                    for (let arm = 0; arm < 2; arm++) {
                        const baseAngle = arm * Math.PI;
                        const spiralAngle = baseAngle + r * 0.3;
                        const x = Math.floor(center + r * Math.cos(spiralAngle));
                        const y = Math.floor(center + r * Math.sin(spiralAngle));
                        
                        if (x >= 0 && x < this.gridSize && y >= 0 && y < this.gridSize) {
                            this.orbital.mass[x][y] = 2 + Math.random() * 3;
                            this.cosmic.density[x][y] = 1.3;
                            const v = Math.sqrt(100 / r) * 0.2;
                            this.orbital.velocity[x][y].x = -v * Math.sin(spiralAngle);
                            this.orbital.velocity[x][y].y = v * Math.cos(spiralAngle);
                        }
                    }
                }
            }
            
            start() {
                this.isRunning = true;
                document.getElementById('startBtn').textContent = '‚è∏Ô∏è PAUSE';
                document.getElementById('startBtn').classList.add('active');
                document.getElementById('statusText').textContent = 'Running';
                this.startAnimation();
            }
            
            stop() {
                this.isRunning = false;
                document.getElementById('startBtn').textContent = '‚ñ∂Ô∏è START';
                document.getElementById('startBtn').classList.remove('active');
                document.getElementById('statusText').textContent = 'Stopped';
                if (animationId) {
                    clearInterval(animationId);
                }
            }
            
            reset() {
                this.stop();
                this.timeStep = 0;
                this.particles = [];
                this.initializeFields();
            }
            
            startAnimation() {
                const speed = parseInt(document.getElementById('speed').value);
                animationId = setInterval(() => {
                    if (this.isRunning) {
                        this.step();
                    }
                }, speed);
            }
            
            startPerformanceMonitoring() {
                setInterval(() => {
                    const now = performance.now();
                    const deltaTime = now - this.lastFrameTime;
                    this.fps = Math.round(1000 / deltaTime);
                    this.lastFrameTime = now;
                    document.getElementById('fpsCounter').textContent = this.fps;
                }, 1000);
            }
        }
        
        // GLOBAL FUNCTIONS
        function toggleSimulation() {
            if (engine.isRunning) {
                engine.stop();
            } else {
                engine.start();
            }
        }
        
        function resetSimulation() {
            engine.reset();
        }
        
        function loadPreset(presetName) {
            engine.loadPreset(presetName);
        }
        
        function updateParam(param, value) {
            engine[param] = parseFloat(value);
            document.getElementById(param + '-display').textContent = parseFloat(value).toFixed(2);
        }
        
        function updateSpeed(value) {
            document.getElementById('speed-display').textContent = value + ' ms';
            if (engine.isRunning) {
                engine.stop();
                engine.start();
            }
        }
        
        // INITIALIZE ENGINE
        window.addEventListener('load', () => {
            console.log('üåå Initializing Complete MBT Engine...');
            engine = new MBTEngine();
            console.log('‚úÖ Engine ready!');
        });
        
        // KEYBOARD SHORTCUTS
        document.addEventListener('keydown', (e) => {
            if (!engine) return;
            
            switch (e.key.toLowerCase()) {
                case ' ':
                    e.preventDefault();
                    toggleSimulation();
                    break;
                case 'r':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        resetSimulation();
                    }
                    break;
                case '1':
                    currentTool = 'quantum';
                    document.querySelector('[data-tool="quantum"]').click();
                    break;
                case '2':
                    currentTool = 'atom';
                    document.querySelector('[data-tool="atom"]').click();
                    break;
                case '3':
                    currentTool = 'molecule';
                    document.querySelector('[data-tool="molecule"]').click();
                    break;
                case '4':
                    currentTool = 'planet';
                    document.querySelector('[data-tool="planet"]').click();
                    break;
                case '5':
                    currentTool = 'energy';
                    document.querySelector('[data-tool="energy"]').click();
                    break;
            }
        });
        
        console.log('üéÆ Complete MBT Physics Engine loaded!');
        console.log('üìã Controls: SPACE=play/pause, Ctrl+R=reset, 1-5=tools');
    </script>
</body>
</html>
